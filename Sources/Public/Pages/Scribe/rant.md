# high level idea
I thinking bringing up the browser is an important point not only is that a lot of complicated code to stand on. It's also a lot of abstractions pilled on top of each other, with the end output being mostly text and some media on the screen. The actual information being shared and what we care about. The simplest way to put text on the screen is the terminal but the delta between and the browser/website is a lot of code! I wonder how much code you actually need to put the same image on the screen with a similar way to interact with the needed information without the legacy of HTML, CSS, and JS. Maybe the harder question is what information do you need and how do you encode it. ChromeOS is interesting but something important is missing (explicitly or implicitly), as we aren't all using it.

I'm not sure if "standing on the shoulders of giants" counts as philosophy, but I think to be careful applying philosophy in general to software. Software isn't real. The hardware and to some degree the instruction sets we use are real but everything above that is to some degree BS (human abstractions). It's not strictly bound by the laws of nature and for this reason we can fake or bend some of the rules. 
Also CS is roughly only 50 years old so the assumption we got it right the first time seems unlikely to me. I have also yet to learn of some keystone that holds up some arch to stand upon. Most of what we seem to be standing on is scaffolding covered up by GUIs IMO. I could argue that Compilers and the OS could be these keystones but I am auguring that they currently aren't.

We are pretty good at learning how to observe and leverage nature but not building good languages or using them to communicate effectively. Which funny enough is what computers due but maybe also be a reason for a lot of conflict in the world. Too much information and not effective ways of communication it. Math might be the best example of our best language as most of the population uses/ speaks it. But from the little I know that even that idea/ language cracks with ideas like incompleteness. Maybe i'm completely wrong :fingers_crossed:  and/or something like "Calculus of constructions" can fix or help with that. But our giants weren't built with that it was built with C and note illegal C in the case of the Linux kernel. Which is undefined behavior making it harder to debug. 

I also don't think x86 or other instruction sets should be thought of as stable ground considering it's another API that hardware is free to do what it wants to conform to the API. Another Specter exploit could pop up and change our current assumptions. Only constant is change it's self right? II use philosophy to argue we shouldn't use philosophy :joy: , Though I don't think this proves i'm wrong.

So we standing on a moving surface because everyone just wants to make there part the best they can. But you can't make change with out something else changing usually. Software is cool in sometimes you can but not often, but modern tools like types can help.

My thought after observing all this is ugh how do I personally manage my interaction  this. Computers/software aren't going way unless something really big collapses. Tech giants can't fix all of the worlds problems for everyone (to big a surface to cover) and if they do it's gonna cost you something; money, information, something else, nothing is free. And it will cost more and more the less option/ choice you have and the more employees to maintain there backwards compatible code. Eventually that company is just working on its own problems (debatably Apple) Not to mention you have to hope that you can keep up with there abstractions/ stay in the part of the pie chart there working on. 

My current thoughts on a possible solution. Lets focus on the parts that touch reality and where the information lies. IMO The screen and mostly buttons (keyboard and software buttons). The screen containing the reason you use it (view and create information) and the buttons of how you interact with it. (I have ideas for touch screens and the mouse) So collections of information and buttons. Well how much information do I need, to use the buttons it interact with the information. Not a lot from my experimentation. Well what collections of information should I focus on first. The common case, well I seem to read and edit symbols like the English alphabet and glyph designers created. Lets focus on how this is arranged and interacted with. And you are pretty much have the users API of most webpages. As a bonus this is more then enough to also create the view and interaction of the files system, shell and other OS abstractions. I can elaborate more on that this API might be try and show you what I have already work as an MVP for.
